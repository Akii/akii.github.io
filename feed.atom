<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Boring Haskell</title>
    <link href="http://blog.akii.de/feed.atom" rel="self" />
    <link href="http://blog.akii.de" />
    <id>http://blog.akii.de/feed.atom</id>
    <author>
        <name>Philipp Maier</name>
        <email>@AkiiZedd</email>
    </author>
    <updated>2018-02-19T00:00:00Z</updated>
    <entry>
    <title>Implementing an efficient GeoIP lookup using STM and Async (Part 1)</title>
    <link href="http://blog.akii.de/posts/2018-02-19-geoip-lookup-part-1.html" />
    <id>http://blog.akii.de/posts/2018-02-19-geoip-lookup-part-1.html</id>
    <published>2018-02-19T00:00:00Z</published>
    <updated>2018-02-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[One of my first private projects I wrote with Haskell involved fetching GeoIP information from a remote service. Now, roughly 1.5 years later, I want to come back to that implementation and reflect on it.]]></summary>
</entry>
<entry>
    <title>Eventsourced aggregates in Haskell</title>
    <link href="http://blog.akii.de/posts/2017-06-04-eventsourcing-in-haskell.html" />
    <id>http://blog.akii.de/posts/2017-06-04-eventsourcing-in-haskell.html</id>
    <published>2017-06-04T00:00:00Z</published>
    <updated>2017-06-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[Introduction to projections and event sourcing aggregates in Haskell. First I'll give a brief implementation of projections using `foldl` along with an example. After that, I explain my approach of using a simple Monad transformer stack to implement aggregates and make actions composable.]]></summary>
</entry>

</feed>
